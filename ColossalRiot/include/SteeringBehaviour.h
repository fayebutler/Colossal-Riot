#ifndef STEERINGBEHAVIOUR_H
#define STEERINGBEHAVIOUR_H

  //----------------------------------------------------------------------------------------------------------------------------
/// @file SteeringBehaviour.h
/// @brief defines behaviours and steering forces
/// Modified from :-
/// Matt Buckland (2005) Programming AI By Example [Book & Source Code]
/// [Accessed 2015] Available from: https://github.com/wangchen/Programming-Game-AI-by-Example-src
  //----------------------------------------------------------------------------------------------------------------------------

#include "EntityManager.h"

//----------------------------------------------------------------------------------------------------------------------
/// @class Steering Behaviours "include/SteeringBehaviour.h"
/// @brief The class to contain all steering behaviours and avoidance
/// @author Faye Butler
/// @version 1.0
/// @date Last revision 10/05/2015 Updated to comply with doxygen and NCCA coding standard
//----------------------------------------------------------------------------------------------------------------------


class Vehicle;
class BaseGameEntity;

class SteeringBehaviour
{
public:
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Steering Behaviour ctor that initializes variables and entity manager
  /// @param[in] agent: pass in the vehicle to utilise the behaviours
  //----------------------------------------------------------------------------------------------------------------------------
  SteeringBehaviour(Vehicle* _agent);

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Steering Behaviour dtor
  //----------------------------------------------------------------------------------------------------------------------------
  ~SteeringBehaviour();


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets seek to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void SeekOn(){m_activeFlags |= seek;} //bitwise OR
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets seek to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void SeekOff(){if(on(seek)) m_activeFlags ^= seek;} //bitwise XOR
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if seek is on
  /// @return Boolean: true if seek is on, false if seek is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isSeekOn(){return on(seek);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of seek
  /// @param[in] _newWeight: pass in the weight to set seek to
  //----------------------------------------------------------------------------------------------------------------------------
  void setSeekWeight(const double _newWeight){m_weightSeek = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of seek
  /// @return Double: the weight of seek
  //----------------------------------------------------------------------------------------------------------------------------
  double getSeekWeight()const{return m_weightSeek;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets flee to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void FleeOn(){m_activeFlags |= flee;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets flee to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void FleeOff(){if(on(flee)) m_activeFlags ^= flee;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if flee is on
  /// @return Boolean: true if flee is on, false if flee is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isFleeOn(){return on(flee);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of flee
  /// @param[in] _newWeight: pass in weight to set flee to
  //----------------------------------------------------------------------------------------------------------------------------
  void setFleeWeight(const double _newWeight){m_weightFlee = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of flee
  /// @return Double: the weight of flee
  //----------------------------------------------------------------------------------------------------------------------------
  double getFleeWeight()const{return m_weightFlee;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets arrive to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void ArriveOn(){m_activeFlags |= arrive;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets arrive to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void ArriveOff(){if(on(arrive)) m_activeFlags ^= arrive;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if arrive is on
  /// @return Boolean: true if arrive is on, false if arrive is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isArriveOn(){return on(arrive);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of arrive
  /// @param[in] _newWeight: pass in weight to set arrive to
  //----------------------------------------------------------------------------------------------------------------------------
  void setArriveWeight(const double _newWeight){m_weightArrive = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of arrive
  /// @return Double: the weight of arrive
  //----------------------------------------------------------------------------------------------------------------------------
  double getArriveWeight()const{return m_weightArrive;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets wander to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void WanderOn(){m_activeFlags |= wander;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets wander to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void WanderOff(){if(on(wander)) m_activeFlags ^= wander;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if wander is on
  /// @return Boolean: true if wander is on, false if wander is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isWanderOn(){return on(wander);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of wander
  /// @param[in] _newWeight: pass in weight to set wander to
  //----------------------------------------------------------------------------------------------------------------------------
  void setWanderWeight(const double _newWeight){m_weightWander = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of wander
  /// @return Double: the weight of wander
  //----------------------------------------------------------------------------------------------------------------------------
  double getWanderWeight()const{return m_weightWander;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets separation to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void SeparationOn(){m_activeFlags |= separation;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets separation to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void SeparationOff(){if(on(separation)) m_activeFlags ^= separation;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if separation is on
  /// @return Boolean: true if separation is on, false if separation is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isSeparationOn(){return on(separation);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of separation
  /// @param[in] _newWeight: pass in weight to set separation to
  //----------------------------------------------------------------------------------------------------------------------------
  void setSeparationWeight(const double _newWeight){m_weightSeparation = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of separation
  /// @return Double: the weight of separation
  //----------------------------------------------------------------------------------------------------------------------------
  double getSeparationWeight()const{return m_weightSeparation;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets alignment to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void AlignmentOn(){m_activeFlags |= alignment;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets alignment to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void AlignmentOff(){if(on(alignment)) m_activeFlags ^= alignment;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if alignment is on
  /// @return Boolean: true if alignment is on, false if alignment is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isAlignmentOn(){return on(alignment);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of alignment
  /// @param[in] _newWeight: pass in the weight to set alignment to
  //----------------------------------------------------------------------------------------------------------------------------
  void setAlignmentWeight(const double _newWeight){m_weightAlignment = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of alignment
  /// @return Double: the weight of alignment
  //----------------------------------------------------------------------------------------------------------------------------
  double getAlignmentWeight()const{return m_weightAlignment;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets cohesion to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void CohesionOn(){m_activeFlags |= cohesion;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets cohesion to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void CohesionOff(){if(on(cohesion)) m_activeFlags ^= cohesion;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if cohesion is on
  /// @return Boolean: true if cohesion is on, false if cohesion is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isCohesionOn(){return on(cohesion);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of cohesion
  /// @param[in] _newWeight: pass in the weight to set cohesion to
  //----------------------------------------------------------------------------------------------------------------------------
  void setCohesionWeight(const double _newWeight){m_weightCohesion = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of cohesion
  /// @return Double: the weight of alignment
  //----------------------------------------------------------------------------------------------------------------------------
  double getCohesionWeight()const{return m_weightCohesion;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets squad cohesion to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void SquadCohesionOn(){m_activeFlags |= squad_cohesion;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets squad cohesion to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void SquadCohesionOff(){if(on(squad_cohesion)) m_activeFlags ^= squad_cohesion;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if squad cohesion is on
  /// @return Boolean: true if squad cohesion is on, false if squad cohesion is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isSquadCohesionOn(){return on(squad_cohesion);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of squad cohesion
  /// @param[in] _newWeight: pass in the weight to set squad cohesion to
  //----------------------------------------------------------------------------------------------------------------------------
  void setSquadCohesionWeight(const double _newWeight){m_weightSquadCohesion = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of squad cohesion
  /// @return Double: the weight of alignment
  //----------------------------------------------------------------------------------------------------------------------------
  double getSquadCohesionWeight()const{return m_weightSquadCohesion;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets pursuit to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void PursuitOn(){m_activeFlags |= pursuit;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets pursuit to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void PursuitOff(){if(on(pursuit)) m_activeFlags ^= pursuit;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if pursuit is on
  /// @return Boolean: true if pursuit is on, false if pursuit is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isPursuitOn(){return on(pursuit);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of pursuit
  /// @param[in] _newWeight: pass in the weight to set pursuit to
  //----------------------------------------------------------------------------------------------------------------------------
  void setPursuitWeight(const double _newWeight){m_weightPursuit = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of pursuit
  /// @return Double: the weight of pursuit
  //----------------------------------------------------------------------------------------------------------------------------
  double getPursuitWeight()const{return m_weightPursuit;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets evade to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void EvadeOn(){m_activeFlags |= evade;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets evade to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void EvadeOff(){if(on(evade)) m_activeFlags ^= evade;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if evade is on
  /// @return Boolean: true if evade is on, false if evade is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isEvadeOn(){return on(evade);}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of evade
  /// @param[in] _newWeight: pass in the weight to set evade to
  //----------------------------------------------------------------------------------------------------------------------------
  void setEvadeWeight(const double _newWeight){m_weightEvade = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of evade
  /// @return Double: the weight of evade
  //----------------------------------------------------------------------------------------------------------------------------
  double getEvadeWeight()const{return m_weightEvade;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets obstacle avoidance to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void ObstacleAvoidOn() { m_activeFlags |= obstacle_avoidance; }
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets obstacle avoidance to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void ObstacleAvoidOff() { if(on(obstacle_avoidance)) m_activeFlags ^= obstacle_avoidance; }
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if obstacle avoidance is on
  /// @return Boolean: true if obstacle avoidance is on, false if obstacle avoidance is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isObstacleAvoidOn() { return on(obstacle_avoidance); }
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of obstacle avoidance
  /// @param[in] _newWeight: pass in the weight to set obstacle avoidance to
  //----------------------------------------------------------------------------------------------------------------------------
  void setObstacleAvoidWeight(const double _newWeight){m_weightObstacleAvoidance = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets obstacle avoidance to on state
  /// @return Double: the weight of obstacle avoidance
  //----------------------------------------------------------------------------------------------------------------------------
  double getObstacleAvoidWeight()const{return m_weightObstacleAvoidance;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets wall avoidance to on state
  //----------------------------------------------------------------------------------------------------------------------------
  void WallAvoidOn() { m_activeFlags |= wall_avoidance; }
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets wall avoidance to off state
  //----------------------------------------------------------------------------------------------------------------------------
  void WallAvoidOff() { if(on(wall_avoidance)) m_activeFlags ^= wall_avoidance; }
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if wall avoidance is on
  /// @return Boolean: true if wall avoidance is on, false if wall avoidance is off
  //----------------------------------------------------------------------------------------------------------------------------
  bool isWallAvoidOn() { return on(wall_avoidance); }
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the weight of wall avoidance
  /// @param[in] _newWeight: pass in the weight to set obstacle avoidance to
  //----------------------------------------------------------------------------------------------------------------------------
  void setWallAvoidWeight(const double _newWeight){m_weightWallAvoidance = _newWeight;}
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Gets the weight of wall avoidance
  /// @return Double: the weight of wall avoidance
  //----------------------------------------------------------------------------------------------------------------------------
  double getWallAvoidWeight()const{return m_weightWallAvoidance;}


  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sets the target agent for pursuit and evade
  /// @param[in] _agent: pass in vehicle to use as target
  //----------------------------------------------------------------------------------------------------------------------------
  void setTargetAgent(Vehicle* _agent){m_targetAgent = _agent;}

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Adds IDs of the neighbours to the m_friendlyNeighbours vector
  /// @param[in] _neighbours: vector of ints that stores the IDs of neighbours
  //----------------------------------------------------------------------------------------------------------------------------
  void addFriendlyNeighbours(std::vector<int> _neighbours);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Clears the m_friendlyNeighbours vector
  //----------------------------------------------------------------------------------------------------------------------------
  void clearFriendlyNeighbours() { m_friendlyNeighbours.clear(); }

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Adds IDs of the neighbours to the m_allNeighbours vector
  /// @param[in] _neighbours: vector of ints that stores the IDs of neighbours
  //----------------------------------------------------------------------------------------------------------------------------
  void addAllNeighbours(std::vector<int> _neighbours);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Clears the m_allNeighbours vector
  //----------------------------------------------------------------------------------------------------------------------------
  void clearAllNeighbours() { m_allNeighbours.clear(); }

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if two lines intersect
  /// @param[in] startLineA: the start vector of the first line
  /// @param[in] endLineA: the end vector of the first line
  /// @param[in] startLineB: the start vector of the second line
  /// @param[in] endLineB: the end vector of the second line
  /// @param[out] o_distToIntersect: the distance to the intersection
  /// @param[out] o_intersectPoint: the vector of the point of intersection
  /// @return Boolean: returns true if the two lines intersect, false if they do not
  //----------------------------------------------------------------------------------------------------------------------------
  bool lineIntersection2D(ngl::Vec3 startLineA, ngl::Vec3 endLineA, ngl::Vec3 startLineB, ngl::Vec3 endLineB, double &o_distToIntersect, ngl::Vec3 &o_intersectPoint);

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Sums together all the steering forces in a prioritized list
  /// @return Vec3: the steering force vector
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 calculatePrioritizedSum();

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Used in calculating the steering force to make sure it does not exceed the maximum force
  /// @param[in] currentTotal: the running total of the steering forces
  /// @param[out] force: the force to be added, returns maximum amount it can fit within maximum force
  /// @return Boolean: returns true if force can be added, false if it cannot
  //----------------------------------------------------------------------------------------------------------------------------
  bool accumulateForce(ngl::Vec3 currentTotal, ngl::Vec3 &force);

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Calculates the overlap for obstacle avoidance
  //----------------------------------------------------------------------------------------------------------------------------
  void ObjectOverlapAvoidance();

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Calculates the overlap for wall avoidance
  //----------------------------------------------------------------------------------------------------------------------------
  void WallOverlapAvoidance();
private:
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief enumerate the list of behaviours
  //----------------------------------------------------------------------------------------------------------------------------
  enum behaviour_type
  {
      seek               = 0x00002, //0
      flee               = 0x00004, //1
      arrive             = 0x00008, //2
      wander             = 0x00010, //3
      cohesion           = 0x00020, //4
      separation         = 0x00040, //5
      alignment          = 0x00080, //6
      obstacle_avoidance = 0x00100, //7
      wall_avoidance     = 0x00200, //8
      pursuit            = 0x00800, //9
      evade              = 0x01000, //10
      squad_cohesion     = 0x02000, //11
  };

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Pointer to the Entity Manage monostate
  //----------------------------------------------------------------------------------------------------------------------------
  EntityManager* m_entityMgr;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Pointer to the current vehicle
  //----------------------------------------------------------------------------------------------------------------------------
  Vehicle* m_vehicle;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Int number of active flags for steering behaviours
  //----------------------------------------------------------------------------------------------------------------------------
  int m_activeFlags;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Vecs for the accumulation of steering behaviour forces
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 m_steeringForce;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Vehicle Pointer to the target agent
  //----------------------------------------------------------------------------------------------------------------------------
  Vehicle* m_targetAgent;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Float for the distance of wander
  //----------------------------------------------------------------------------------------------------------------------------
  float m_wanderDistance;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Float for the radius of wander
  //----------------------------------------------------------------------------------------------------------------------------
  float m_wanderRadius;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Float for the jitter amount of wander
  //----------------------------------------------------------------------------------------------------------------------------
  float m_wanderJitter;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Int for the amount of deceleration
  //----------------------------------------------------------------------------------------------------------------------------
  int m_deceleration;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Vec3 for the wander target
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 m_wanderTarget;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Vector to contain the IDs of the friendly neighbours
  //----------------------------------------------------------------------------------------------------------------------------
  std::vector<int> m_friendlyNeighbours;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Vector to contain the IDs of all the neighbours
  //----------------------------------------------------------------------------------------------------------------------------
  std::vector<int> m_allNeighbours;

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Returns if a steering behaviour is set to on
  /// @param[in] enum: the behaviour type
  /// @return Boolean: returns true if the behaviour is on, false if it is not
  //----------------------------------------------------------------------------------------------------------------------------
  bool on(behaviour_type bt){return (m_activeFlags & bt) == bt;}

  //multipliers to adjust strength of behaviour

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of seek
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightSeek;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of flee
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightFlee;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of arrive
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightArrive;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of wander
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightWander;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of cohesion
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightCohesion;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of separation
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightSeparation;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of alignment
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightAlignment;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of obstacle avoidance
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightObstacleAvoidance;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of wall avoidance
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightWallAvoidance;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of pursuit
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightPursuit;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of evade
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightEvade;
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief The weight of squad cohesion
  //----------------------------------------------------------------------------------------------------------------------------
  double m_weightSquadCohesion;


  //  behaviour type functions
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Seek behaviour type
  /// @param[in] targetPos: vector of the target position
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Seek(ngl::Vec3 targetPos);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Flee behaviour type
  /// @param[in] targetPos: vector of the target position
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Flee(ngl::Vec3 targetPos);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Arrive behaviour type
  /// @param[in] targetPos: vector of the target position
  /// @param[in] deceleration: the amount to decelerate by
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Arrive(ngl::Vec3 targetPos, int deceleration);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Wander behaviour type
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Wander();
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Pursuit behaviour type
  /// @param[in] agent: pointer to the target agent
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Pursuit(const Vehicle *agent);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Evade behaviour type
  /// @param[in] agent: pointer to the target agent
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Evade(const Vehicle* agent);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Separation behaviour type
  /// @param[in] neighbours: vector of ints to contain the IDs of the neighbours
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Separation(std::vector<int> neighbours);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Alignment behaviour type
  /// @param[in] neighbours: vector of ints to contain the IDs of the neighbours
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Alignment(std::vector<int> neighbours);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Cohesion behaviour type
  /// @param[in] neighbours: vector of ints to contain the IDs of the neighbours
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 Cohesion(std::vector<int> neighbours);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Squad Cohesion behaviour type
  /// @param[in] squadPos: vector of the target squad position
  /// @param[in] deceleration: the amount to decelerate by
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 SquadCohesion(ngl::Vec3 squadPos, int deceleration);
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Obstacle Avoidance behaviour
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 ObstacleAvoidance();
  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Wall Avoidance behaviour
  /// @return Vec3: the steering force
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 WallAvoidance();

  //----------------------------------------------------------------------------------------------------------------------------
  /// @brief Convert from world to local space
  /// @param[in] pointWorldPos: the vector of the point in world space
  /// @param[in] vehiclePos: vector of the position of the vehicle
  /// @param[in] vehicleHeading: vector of the heading of the vehicle
  /// @param[in] vehicleSide: vector of the side of the vehicle
  /// @return Vec3: the vector of the point in local space
  //----------------------------------------------------------------------------------------------------------------------------
  ngl::Vec3 worldToLocalSpace(ngl::Vec3 pointWorldPos, ngl::Vec3 vehiclePos, ngl::Vec3 vehicleHeading, ngl::Vec3 vehicleSide);

};

#endif // STEERINGBEHAVIOUR_H
